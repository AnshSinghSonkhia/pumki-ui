{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "custom-curved-arrow",
  "type": "registry:block",
  "title": "Custom Curved Arrow",
  "description": "A component for displaying a custom curved arrow between two elements.",
  "author": "Ansh Singh Sonkhia",
  "dependencies": [
    "react"
  ],
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "type": "registry:block",
      "content": "\"use client\";\r\n\r\nimport React, { useEffect, useState, useRef, useCallback } from \"react\";\r\n\r\ninterface CustomCurvedArrowProps {\r\n  startElement: React.RefObject<HTMLElement | null> | null;\r\n  endElement: React.RefObject<HTMLElement | null> | null;\r\n  obstacleElement?: React.RefObject<HTMLElement | null> | null;\r\n  startX?: number;\r\n  startY?: number;\r\n  endX?: number;\r\n  endY?: number;\r\n  curveIntensity?: number;\r\n  curveType?:\r\n    | \"smooth\"\r\n    | \"dramatic\"\r\n    | \"s-curve\"\r\n    | \"wave\"\r\n    | \"spiral\"\r\n    | \"elegant\"\r\n    | \"shortest-path\"\r\n    | \"around-obstacle\";\r\n  curveDirection?: \"auto\" | \"up\" | \"down\" | \"left\" | \"right\";\r\n  strokeWidth?: number;\r\n  arrowSize?: number;\r\n  className?: string;\r\n  animated?: boolean;\r\n  startPosition?:\r\n    | \"top\"\r\n    | \"bottom\"\r\n    | \"left\"\r\n    | \"right\"\r\n    | \"center\"\r\n    | \"top-left\"\r\n    | \"top-right\"\r\n    | \"bottom-left\"\r\n    | \"bottom-right\";\r\n  endPosition?:\r\n    | \"top\"\r\n    | \"bottom\"\r\n    | \"left\"\r\n    | \"right\"\r\n    | \"center\"\r\n    | \"top-left\"\r\n    | \"top-right\"\r\n    | \"bottom-left\"\r\n    | \"bottom-right\";\r\n}\r\n\r\ninterface Coordinates {\r\n  startX: number;\r\n  startY: number;\r\n  endX: number;\r\n  endY: number;\r\n  obstacleRect: { x: number; y: number; width: number; height: number } | null;\r\n}\r\n\r\nexport function CustomCurvedArrow({\r\n  startElement,\r\n  endElement,\r\n  obstacleElement,\r\n  startX = 0,\r\n  startY = 0,\r\n  endX = 100,\r\n  endY = 100,\r\n  curveIntensity = 0.4,\r\n  curveType = \"smooth\",\r\n  curveDirection = \"auto\",\r\n  strokeWidth = 4,\r\n  arrowSize = 20,\r\n  className = \"\",\r\n  startPosition = \"bottom\",\r\n  endPosition = \"top\",\r\n}: CustomCurvedArrowProps) {\r\n  const [coordinates, setCoordinates] = useState<Coordinates>({\r\n    startX,\r\n    startY,\r\n    endX,\r\n    endY,\r\n    obstacleRect: null,\r\n  });\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n\r\n  const calculatePosition = useCallback(\r\n    (element: HTMLElement, position: string) => {\r\n      const rect = element.getBoundingClientRect();\r\n      const containerRect = containerRef.current?.getBoundingClientRect();\r\n\r\n      if (!containerRect) return { x: 0, y: 0 };\r\n\r\n      const relativeX = rect.left - containerRect.left;\r\n      const relativeY = rect.top - containerRect.top;\r\n\r\n      // Add padding adjustments for more accurate positioning\r\n      const padding = 5;\r\n\r\n      switch (position) {\r\n        case \"top\":\r\n          return { x: relativeX + rect.width / 2, y: relativeY - padding };\r\n        case \"bottom\":\r\n          return {\r\n            x: relativeX + rect.width / 2,\r\n            y: relativeY + rect.height + padding,\r\n          };\r\n        case \"left\":\r\n          return { x: relativeX - padding, y: relativeY + rect.height / 2 };\r\n        case \"right\":\r\n          return {\r\n            x: relativeX + rect.width + padding,\r\n            y: relativeY + rect.height / 2,\r\n          };\r\n        case \"center\":\r\n          return {\r\n            x: relativeX + rect.width / 2,\r\n            y: relativeY + rect.height / 2,\r\n          };\r\n        case \"top-left\":\r\n          return { x: relativeX, y: relativeY };\r\n        case \"top-right\":\r\n          return { x: relativeX + rect.width, y: relativeY };\r\n        case \"bottom-left\":\r\n          return { x: relativeX, y: relativeY + rect.height };\r\n        case \"bottom-right\":\r\n          return { x: relativeX + rect.width, y: relativeY + rect.height };\r\n        default:\r\n          return {\r\n            x: relativeX + rect.width / 2,\r\n            y: relativeY + rect.height / 2,\r\n          };\r\n      }\r\n    },\r\n    [containerRef]\r\n  );\r\n\r\n  const updateCoordinates = useCallback(() => {\r\n    if (startElement?.current && endElement?.current && containerRef.current) {\r\n      const startPos = calculatePosition(startElement.current, startPosition);\r\n      const endPos = calculatePosition(endElement.current, endPosition);\r\n\r\n      let obstacleRect: Coordinates[\"obstacleRect\"] = null;\r\n      if (obstacleElement?.current && containerRef.current) {\r\n        const obstacleElementRect =\r\n          obstacleElement.current.getBoundingClientRect();\r\n        const containerRect = containerRef.current.getBoundingClientRect();\r\n        obstacleRect = {\r\n          x: obstacleElementRect.left - containerRect.left,\r\n          y: obstacleElementRect.top - containerRect.top,\r\n          width: obstacleElementRect.width,\r\n          height: obstacleElementRect.height,\r\n        };\r\n      }\r\n\r\n      setCoordinates({\r\n        startX: startPos.x,\r\n        startY: startPos.y,\r\n        endX: endPos.x,\r\n        endY: endPos.y,\r\n        obstacleRect,\r\n      });\r\n    }\r\n  }, [\r\n    startElement,\r\n    endElement,\r\n    obstacleElement,\r\n    startPosition,\r\n    endPosition,\r\n    calculatePosition,\r\n    containerRef,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (startElement?.current && endElement?.current) {\r\n      updateCoordinates();\r\n\r\n      const resizeObserver = new ResizeObserver(() => {\r\n        updateCoordinates();\r\n      });\r\n\r\n      const mutationObserver = new MutationObserver(() => {\r\n        updateCoordinates();\r\n      });\r\n\r\n      // Observe both elements and their parents\r\n      if (startElement.current) {\r\n        resizeObserver.observe(startElement.current);\r\n        mutationObserver.observe(startElement.current, {\r\n          attributes: true,\r\n          childList: true,\r\n          subtree: true,\r\n        });\r\n      }\r\n      if (endElement.current) {\r\n        resizeObserver.observe(endElement.current);\r\n        mutationObserver.observe(endElement.current, {\r\n          attributes: true,\r\n          childList: true,\r\n          subtree: true,\r\n        });\r\n      }\r\n      if (obstacleElement?.current) {\r\n        resizeObserver.observe(obstacleElement.current);\r\n        mutationObserver.observe(obstacleElement.current, {\r\n          attributes: true,\r\n          childList: true,\r\n          subtree: true,\r\n        });\r\n      }\r\n\r\n      // Also observe window resize\r\n      const handleResize = () => {\r\n        setTimeout(updateCoordinates, 100);\r\n      };\r\n      window.addEventListener(\"resize\", handleResize);\r\n      window.addEventListener(\"scroll\", updateCoordinates);\r\n\r\n      return () => {\r\n        resizeObserver.disconnect();\r\n        mutationObserver.disconnect();\r\n        window.removeEventListener(\"resize\", handleResize);\r\n        window.removeEventListener(\"scroll\", updateCoordinates);\r\n      };\r\n    }\r\n  }, [\r\n    startElement,\r\n    endElement,\r\n    obstacleElement,\r\n    startPosition,\r\n    endPosition,\r\n    updateCoordinates,\r\n  ]);\r\n\r\n  const {\r\n    startX: calcStartX,\r\n    startY: calcStartY,\r\n    endX: calcEndX,\r\n    endY: calcEndY,\r\n    obstacleRect,\r\n  } = coordinates;\r\n\r\n  const createCurvePath = () => {\r\n    const dx = calcEndX - calcStartX;\r\n    const dy = calcEndY - calcStartY;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    // Auto-determine curve direction if not specified\r\n    let effectiveDirection = curveDirection;\r\n    if (curveDirection === \"auto\") {\r\n      if (Math.abs(dx) > Math.abs(dy)) {\r\n        effectiveDirection = dy > 0 ? \"down\" : \"up\";\r\n      } else {\r\n        effectiveDirection = dx > 0 ? \"right\" : \"left\";\r\n      }\r\n    }\r\n\r\n    // Calculate curve offset based on direction\r\n    let offsetX = 0;\r\n    let offsetY = 0;\r\n    const baseOffset = Math.min(distance * curveIntensity, 200);\r\n\r\n    switch (effectiveDirection) {\r\n      case \"up\":\r\n        offsetY = -baseOffset;\r\n        break;\r\n      case \"down\":\r\n        offsetY = baseOffset;\r\n        break;\r\n      case \"left\":\r\n        offsetX = -baseOffset;\r\n        break;\r\n      case \"right\":\r\n        offsetX = baseOffset;\r\n        break;\r\n    }\r\n\r\n    let pathString = \"\";\r\n    let control1X: number = 0;\r\n    let control1Y: number = 0;\r\n    let control2X: number = 0;\r\n    let control2Y: number = 0;\r\n\r\n    switch (curveType) {\r\n      case \"shortest-path\":\r\n        if (obstacleRect) {\r\n          // Calculate the shortest path around the obstacle with better rounding\r\n          const obstacleMargin = 40; // Margin for rounding the descriptions\r\n\r\n          // Define obstacle boundaries\r\n          const obstacleTop = obstacleRect.y - obstacleMargin;\r\n          const obstacleBottom =\r\n            obstacleRect.y + obstacleRect.height + obstacleMargin;\r\n          const obstacleLeft = obstacleRect.x - obstacleMargin;\r\n          const obstacleRight =\r\n            obstacleRect.x + obstacleRect.width + obstacleMargin;\r\n\r\n          // Since we start from top-left of Step 2 image and need to round the descriptions\r\n          // We'll create a path that goes right and curves around the descriptions\r\n\r\n          if (calcEndX > obstacleRight && calcStartX < obstacleLeft) {\r\n            // Path goes around the right side of descriptions\r\n            const waypoint1X = obstacleRight + baseOffset * 0.4;\r\n            const waypoint1Y = obstacleTop + obstacleRect.height * 0.3;\r\n\r\n            const waypoint2X = obstacleRight + baseOffset * 0.2;\r\n            const waypoint2Y = obstacleBottom - baseOffset * 0.1;\r\n\r\n            // Control points for smooth rounding\r\n            control1X = calcStartX + (waypoint1X - calcStartX) * 0.3;\r\n            control1Y = calcStartY + (waypoint1Y - calcStartY) * 0.4;\r\n\r\n            const midControlX = waypoint1X + baseOffset * 0.1;\r\n            const midControlY = waypoint1Y + (waypoint2Y - waypoint1Y) * 0.5;\r\n\r\n            control2X = waypoint2X + (calcEndX - waypoint2X) * 0.4;\r\n            control2Y = waypoint2Y + (calcEndY - waypoint2Y) * 0.6;\r\n\r\n            // Create smooth rounding path\r\n            pathString = `M ${calcStartX} ${calcStartY} \r\n                         C ${control1X} ${control1Y} ${waypoint1X - 30} ${\r\n              waypoint1Y - 15\r\n            } ${waypoint1X} ${waypoint1Y}\r\n                         C ${midControlX} ${midControlY} ${waypoint2X - 20} ${\r\n              waypoint2Y + 10\r\n            } ${waypoint2X} ${waypoint2Y}\r\n                         C ${control2X} ${control2Y} ${calcEndX - 40} ${\r\n              calcEndY - 25\r\n            } ${calcEndX} ${calcEndY}`;\r\n          } else {\r\n            // Fallback path - go over the top if right path isn't optimal\r\n            const waypointX = (calcStartX + calcEndX) / 2 + baseOffset * 0.3;\r\n            const waypointY = obstacleTop - baseOffset * 0.2;\r\n\r\n            control1X = calcStartX + (waypointX - calcStartX) * 0.4;\r\n            control1Y = calcStartY + (waypointY - calcStartY) * 0.6;\r\n            control2X = waypointX + (calcEndX - waypointX) * 0.6;\r\n            control2Y = waypointY + (calcEndY - waypointY) * 0.4;\r\n\r\n            pathString = `M ${calcStartX} ${calcStartY} \r\n                         C ${control1X} ${control1Y} ${\r\n              waypointX - 20\r\n            } ${waypointY} ${waypointX} ${waypointY}\r\n                         C ${control2X} ${control2Y} ${calcEndX - 30} ${\r\n              calcEndY - 20\r\n            } ${calcEndX} ${calcEndY}`;\r\n          }\r\n        } else {\r\n          // Direct path if no obstacle\r\n          control1X = calcStartX + dx * 0.3;\r\n          control1Y = calcStartY + dy * 0.3;\r\n          control2X = calcEndX - dx * 0.3;\r\n          control2Y = calcEndY - dy * 0.3;\r\n          pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        }\r\n        break;\r\n\r\n      case \"around-obstacle\":\r\n        if (obstacleRect) {\r\n          // Create a path that curves around the obstacle from top-left\r\n          const obstacleMargin = 60; // Extra space around obstacle\r\n          const obstacleLeft = obstacleRect.x - obstacleMargin;\r\n          const obstacleRight =\r\n            obstacleRect.x + obstacleRect.width + obstacleMargin;\r\n          const obstacleBottom =\r\n            obstacleRect.y + obstacleRect.height + obstacleMargin;\r\n\r\n          // Since we start from top-left, we need to go left first, then around\r\n          // First curve: go left and down to avoid the obstacle\r\n          const waypoint1X = Math.min(\r\n            calcStartX - baseOffset * 0.8,\r\n            obstacleLeft\r\n          );\r\n          const waypoint1Y = calcStartY + (obstacleBottom - calcStartY) * 0.4;\r\n\r\n          // Second curve: go around the bottom of the obstacle\r\n          const waypoint2X = obstacleRight + baseOffset * 0.3;\r\n          const waypoint2Y = obstacleBottom + baseOffset * 0.2;\r\n\r\n          // Control points for smooth curves\r\n          control1X = calcStartX + (waypoint1X - calcStartX) * 0.3;\r\n          control1Y = calcStartY + (waypoint1Y - calcStartY) * 0.5;\r\n\r\n          const midControlX = waypoint1X - baseOffset * 0.2;\r\n          const midControlY = waypoint1Y + (waypoint2Y - waypoint1Y) * 0.5;\r\n\r\n          control2X = waypoint2X + (calcEndX - waypoint2X) * 0.3;\r\n          control2Y = waypoint2Y + (calcEndY - waypoint2Y) * 0.3;\r\n\r\n          // Create a complex path that goes around the obstacle from top-left\r\n          pathString = `M ${calcStartX} ${calcStartY} \r\n                       C ${control1X} ${control1Y} ${waypoint1X + 20} ${\r\n            waypoint1Y - 20\r\n          } ${waypoint1X} ${waypoint1Y}\r\n                       C ${midControlX} ${midControlY} ${waypoint2X - 40} ${\r\n            waypoint2Y - 20\r\n          } ${waypoint2X} ${waypoint2Y}\r\n                       C ${control2X} ${control2Y} ${calcEndX - 50} ${\r\n            calcEndY - 30\r\n          } ${calcEndX} ${calcEndY}`;\r\n        } else {\r\n          // Fallback to elegant curve if no obstacle\r\n          control1X = calcStartX + dx * 0.2 + offsetX * 0.4;\r\n          control1Y = calcStartY + dy * 0.2 + offsetY * 0.4;\r\n          const midControlX = (calcStartX + calcEndX) / 2 + offsetX * 0.8;\r\n          const midControlY = (calcStartY + calcEndY) / 2 + offsetY * 0.8;\r\n          control2X = calcEndX - dx * 0.2 + offsetX * 0.4;\r\n          control2Y = calcEndY - dy * 0.2 + offsetY * 0.4;\r\n\r\n          pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${midControlX} ${midControlY} ${\r\n            (calcStartX + calcEndX) / 2\r\n          } ${\r\n            (calcStartY + calcEndY) / 2\r\n          } S ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        }\r\n        break;\r\n\r\n      case \"smooth\":\r\n        control1X = calcStartX + dx * 0.3 + offsetX * 0.5;\r\n        control1Y = calcStartY + dy * 0.3 + offsetY * 0.5;\r\n        control2X = calcEndX - dx * 0.3 + offsetX * 0.5;\r\n        control2Y = calcEndY - dy * 0.3 + offsetY * 0.5;\r\n        pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        break;\r\n\r\n      case \"dramatic\":\r\n        control1X = calcStartX + dx * 0.1 + offsetX * 1.2;\r\n        control1Y = calcStartY + dy * 0.1 + offsetY * 1.2;\r\n        control2X = calcEndX - dx * 0.1 + offsetX * 1.2;\r\n        control2Y = calcEndY - dy * 0.1 + offsetY * 1.2;\r\n        pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        break;\r\n\r\n      case \"s-curve\":\r\n        control1X = calcStartX + dx * 0.25 + offsetX * 3.8;\r\n        control1Y = calcStartY + dy * 0.25 + offsetY * 0.8;\r\n        control2X = calcEndX - dx * 0.25 - offsetX * 0.8;\r\n        control2Y = calcEndY - dy * 0.25 - offsetY * 0.8;\r\n        pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        break;\r\n\r\n      case \"wave\":\r\n        const wavePoints: { x: number; y: number }[] = [];\r\n        const segments = 3;\r\n        for (let i = 0; i <= segments; i++) {\r\n          const t = i / segments;\r\n          const x = calcStartX + dx * t;\r\n          const y =\r\n            calcStartY + dy * t + Math.sin(t * Math.PI * 2) * offsetY * 0.3;\r\n          wavePoints.push({ x, y });\r\n        }\r\n        pathString = `M ${wavePoints[0].x} ${wavePoints[0].y}`;\r\n        for (let i = 1; i < wavePoints.length; i++) {\r\n          const prev = wavePoints[i - 1];\r\n          const curr = wavePoints[i];\r\n          const cpX = prev.x + (curr.x - prev.x) * 0.5;\r\n          const cpY = prev.y + (curr.y - prev.y) * 0.5 + offsetY * 0.2;\r\n          pathString += ` Q ${cpX} ${cpY} ${curr.x} ${curr.y}`;\r\n        }\r\n        control2X = wavePoints[wavePoints.length - 2].x;\r\n        control2Y = wavePoints[wavePoints.length - 2].y;\r\n        break;\r\n\r\n      case \"spiral\":\r\n        const spiralRadius = Math.min(distance * 0.2, 80);\r\n        const centerX = (calcStartX + calcEndX) / 2 + offsetX * 0.5;\r\n        const centerY = (calcStartY + calcEndY) / 2 + offsetY * 0.5;\r\n\r\n        pathString = `M ${calcStartX} ${calcStartY}`;\r\n        pathString += ` Q ${\r\n          centerX - spiralRadius\r\n        } ${centerY} ${centerX} ${centerY}`;\r\n        pathString += ` Q ${\r\n          centerX + spiralRadius\r\n        } ${centerY} ${calcEndX} ${calcEndY}`;\r\n\r\n        control2X = centerX + spiralRadius;\r\n        control2Y = centerY;\r\n        break;\r\n\r\n      case \"elegant\":\r\n        control1X = calcStartX + dx * 0.2 + offsetX * 0.4;\r\n        control1Y = calcStartY + dy * 0.2 + offsetY * 0.4;\r\n        const midControlX = (calcStartX + calcEndX) / 2 + offsetX * 0.8;\r\n        const midControlY = (calcStartY + calcEndY) / 2 + offsetY * 0.8;\r\n        control2X = calcEndX - dx * 0.2 + offsetX * 0.4;\r\n        control2Y = calcEndY - dy * 0.2 + offsetY * 0.4;\r\n\r\n        pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${midControlX} ${midControlY} ${\r\n          (calcStartX + calcEndX) / 2\r\n        } ${\r\n          (calcStartY + calcEndY) / 2\r\n        } S ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n        break;\r\n\r\n      default:\r\n        // Default smooth curve\r\n        control1X = calcStartX + dx * 0.3 + offsetX * 0.5;\r\n        control1Y = calcStartY + dy * 0.3 + offsetY * 0.5;\r\n        control2X = calcEndX - dx * 0.3 + offsetX * 0.5;\r\n        control2Y = calcEndY - dy * 0.3 + offsetY * 0.5;\r\n        pathString = `M ${calcStartX} ${calcStartY} C ${control1X} ${control1Y} ${control2X} ${control2Y} ${calcEndX} ${calcEndY}`;\r\n    }\r\n\r\n    return {\r\n      pathString,\r\n      control2X: control2X || calcEndX,\r\n      control2Y: control2Y || calcEndY,\r\n    };\r\n  };\r\n\r\n  const { pathString, control2X, control2Y } = createCurvePath();\r\n\r\n  // Calculate arrow head angle\r\n  const endAngle = Math.atan2(calcEndY - control2Y, calcEndX - control2X);\r\n  const arrowAngle = Math.PI / 6;\r\n  const arrowX1 = calcEndX - arrowSize * Math.cos(endAngle - arrowAngle);\r\n  const arrowY1 = calcEndY - arrowSize * Math.sin(endAngle - arrowAngle);\r\n  const arrowX2 = calcEndX - arrowSize * Math.cos(endAngle + arrowAngle);\r\n  const arrowY2 = calcEndY - arrowSize * Math.sin(endAngle + arrowAngle);\r\n\r\n  const arrowHead = `M ${calcEndX} ${calcEndY} L ${arrowX1} ${arrowY1} M ${calcEndX} ${calcEndY} L ${arrowX2} ${arrowY2}`;\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`absolute inset-0 pointer-events-none ${className}`}\r\n    >\r\n      <svg\r\n        width=\"100%\"\r\n        height=\"100%\"\r\n        className=\"absolute inset-0\"\r\n        style={{\r\n          filter: `drop-shadow(0 4px 12px rgba(133, 45, 238, 0.3))`,\r\n          zIndex: 10,\r\n          overflow: \"visible\",\r\n        }}\r\n        preserveAspectRatio=\"none\"\r\n      >\r\n        {/* Gradient Definition */}\r\n        <defs>\r\n          <linearGradient\r\n            id=\"purpleGradient\"\r\n            x1=\"0%\"\r\n            y1=\"0%\"\r\n            x2=\"100%\"\r\n            y2=\"100%\"\r\n          >\r\n            <stop offset=\"0%\" stopColor=\"#ffffff\" />\r\n            <stop offset=\"100%\" stopColor=\"#852DEE\" />\r\n          </linearGradient>\r\n          <filter id=\"glow\">\r\n            <feGaussianBlur stdDeviation=\"3\" result=\"coloredBlur\" />\r\n            <feMerge>\r\n              <feMergeNode in=\"coloredBlur\" />\r\n              <feMergeNode in=\"SourceGraphic\" />\r\n            </feMerge>\r\n          </filter>\r\n        </defs>\r\n\r\n        {/* Glow effect background */}\r\n        <path\r\n          d={pathString}\r\n          stroke=\"url(#purpleGradient)\"\r\n          strokeWidth={strokeWidth + 4}\r\n          fill=\"none\"\r\n          strokeLinecap=\"round\"\r\n          opacity=\"0.3\"\r\n          filter=\"url(#glow)\"\r\n        />\r\n\r\n        {/* Main curved arrow line */}\r\n        <path\r\n          d={pathString}\r\n          stroke=\"url(#purpleGradient)\"\r\n          strokeWidth={strokeWidth}\r\n          fill=\"none\"\r\n          strokeLinecap=\"round\"\r\n        />\r\n\r\n        {/* Arrow Head */}\r\n        <path\r\n          d={arrowHead}\r\n          stroke=\"url(#purpleGradient)\"\r\n          strokeWidth={strokeWidth}\r\n          fill=\"none\"\r\n          strokeLinecap=\"round\"\r\n        />\r\n      </svg>\r\n    </div>\r\n  );\r\n}",
      "path": "components/pumki-ui/sections/timeline/custom-curved-arrow.tsx",
      "target": "components/pumki-ui/sections/timeline/custom-curved-arrow.tsx"
    }
  ]
}