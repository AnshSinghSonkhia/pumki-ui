{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bg-grid-distort",
  "type": "registry:ui",
  "title": "Grid Distort Background",
  "description": "Get Grid Distort background",
  "author": "Ansh Singh Sonkhia",
  "dependencies": [
    "react",
    "three"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\";\r\n\r\nimport React, { useRef, useEffect } from \"react\";\r\nimport * as THREE from \"three\";\r\n\r\ninterface GridDistortionProps {\r\n  grid?: number;\r\n  mouse?: number;\r\n  strength?: number;\r\n  relaxation?: number;\r\n  imageSrc: string;\r\n  className?: string;\r\n}\r\n\r\nconst vertexShader = `\r\nuniform float time;\r\nvarying vec2 vUv;\r\nvarying vec3 vPosition;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  vPosition = position;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `\r\nuniform sampler2D uDataTexture;\r\nuniform sampler2D uTexture;\r\nuniform vec4 resolution;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv;\r\n  vec4 offset = texture2D(uDataTexture, vUv);\r\n  gl_FragColor = texture2D(uTexture, uv - 0.02 * offset.rg);\r\n}\r\n`;\r\n\r\nconst GridDistortion: React.FC<GridDistortionProps> = ({\r\n  grid = 15,\r\n  mouse = 0.1,\r\n  strength = 0.15,\r\n  relaxation = 0.9,\r\n  imageSrc,\r\n  className = \"\",\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const imageAspectRef = useRef<number>(1);\r\n  const cameraRef = useRef<THREE.OrthographicCamera | null>(null);\r\n  const initialDataRef = useRef<Float32Array | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const container = containerRef.current;\r\n    const scene = new THREE.Scene();\r\n    const renderer = new THREE.WebGLRenderer({\r\n      antialias: true,\r\n      alpha: true,\r\n      powerPreference: \"high-performance\",\r\n    });\r\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\r\n    container.appendChild(renderer.domElement);\r\n\r\n    const camera = new THREE.OrthographicCamera(0, 0, 0, 0, -1000, 1000);\r\n    camera.position.z = 2;\r\n    cameraRef.current = camera;\r\n\r\n    const uniforms = {\r\n      time: { value: 0 },\r\n      resolution: { value: new THREE.Vector4() },\r\n      uTexture: { value: null as THREE.Texture | null },\r\n      uDataTexture: { value: null as THREE.DataTexture | null },\r\n    };\r\n\r\n    const textureLoader = new THREE.TextureLoader();\r\n    textureLoader.load(imageSrc, (texture) => {\r\n      texture.minFilter = THREE.LinearFilter;\r\n      imageAspectRef.current = texture.image.width / texture.image.height;\r\n      uniforms.uTexture.value = texture;\r\n      handleResize();\r\n    });\r\n\r\n    const size = grid;\r\n    const data = new Float32Array(4 * size * size);\r\n    for (let i = 0; i < size * size; i++) {\r\n      data[i * 4] = Math.random() * 255 - 125;\r\n      data[i * 4 + 1] = Math.random() * 255 - 125;\r\n    }\r\n    initialDataRef.current = new Float32Array(data);\r\n\r\n    const dataTexture = new THREE.DataTexture(\r\n      data,\r\n      size,\r\n      size,\r\n      THREE.RGBAFormat,\r\n      THREE.FloatType\r\n    );\r\n    dataTexture.needsUpdate = true;\r\n    uniforms.uDataTexture.value = dataTexture;\r\n\r\n    const material = new THREE.ShaderMaterial({\r\n      side: THREE.DoubleSide,\r\n      uniforms,\r\n      vertexShader,\r\n      fragmentShader,\r\n    });\r\n    const geometry = new THREE.PlaneGeometry(1, 1, size - 1, size - 1);\r\n    const plane = new THREE.Mesh(geometry, material);\r\n    scene.add(plane);\r\n\r\n    const handleResize = () => {\r\n      const width = container.offsetWidth;\r\n      const height = container.offsetHeight;\r\n      const containerAspect = width / height;\r\n      const imageAspect = imageAspectRef.current;\r\n\r\n      renderer.setSize(width, height);\r\n\r\n      const scale = Math.max(containerAspect / imageAspect, 1);\r\n      plane.scale.set(imageAspect * scale, scale, 1);\r\n\r\n      const frustumHeight = 1;\r\n      const frustumWidth = frustumHeight * containerAspect;\r\n      camera.left = -frustumWidth / 2;\r\n      camera.right = frustumWidth / 2;\r\n      camera.top = frustumHeight / 2;\r\n      camera.bottom = -frustumHeight / 2;\r\n      camera.updateProjectionMatrix();\r\n\r\n      uniforms.resolution.value.set(width, height, 1, 1);\r\n    };\r\n\r\n    const mouseState = {\r\n      x: 0,\r\n      y: 0,\r\n      prevX: 0,\r\n      prevY: 0,\r\n      vX: 0,\r\n      vY: 0,\r\n    };\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const rect = container.getBoundingClientRect();\r\n      const x = (e.clientX - rect.left) / rect.width;\r\n      const y = 1 - (e.clientY - rect.top) / rect.height;\r\n      mouseState.vX = x - mouseState.prevX;\r\n      mouseState.vY = y - mouseState.prevY;\r\n      Object.assign(mouseState, { x, y, prevX: x, prevY: y });\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      dataTexture.needsUpdate = true;\r\n      Object.assign(mouseState, {\r\n        x: 0,\r\n        y: 0,\r\n        prevX: 0,\r\n        prevY: 0,\r\n        vX: 0,\r\n        vY: 0,\r\n      });\r\n    };\r\n\r\n    container.addEventListener(\"mousemove\", handleMouseMove);\r\n    container.addEventListener(\"mouseleave\", handleMouseLeave);\r\n    window.addEventListener(\"resize\", handleResize);\r\n    handleResize();\r\n\r\n    const animate = () => {\r\n      requestAnimationFrame(animate);\r\n      uniforms.time.value += 0.05;\r\n\r\n      const data = dataTexture.image.data as Float32Array;\r\n      for (let i = 0; i < size * size; i++) {\r\n        data[i * 4] *= relaxation;\r\n        data[i * 4 + 1] *= relaxation;\r\n      }\r\n\r\n      const gridMouseX = size * mouseState.x;\r\n      const gridMouseY = size * mouseState.y;\r\n      const maxDist = size * mouse;\r\n\r\n      for (let i = 0; i < size; i++) {\r\n        for (let j = 0; j < size; j++) {\r\n          const distSq =\r\n            Math.pow(gridMouseX - i, 2) + Math.pow(gridMouseY - j, 2);\r\n          if (distSq < maxDist * maxDist) {\r\n            const index = 4 * (i + size * j);\r\n            const power = Math.min(maxDist / Math.sqrt(distSq), 10);\r\n            data[index] += strength * 100 * mouseState.vX * power;\r\n            data[index + 1] -= strength * 100 * mouseState.vY * power;\r\n          }\r\n        }\r\n      }\r\n\r\n      dataTexture.needsUpdate = true;\r\n      renderer.render(scene, camera);\r\n    };\r\n    animate();\r\n\r\n    return () => {\r\n      container.removeEventListener(\"mousemove\", handleMouseMove);\r\n      container.removeEventListener(\"mouseleave\", handleMouseLeave);\r\n      window.removeEventListener(\"resize\", handleResize);\r\n      renderer.dispose();\r\n      geometry.dispose();\r\n      material.dispose();\r\n      dataTexture.dispose();\r\n      if (uniforms.uTexture.value) uniforms.uTexture.value.dispose();\r\n    };\r\n  }, [grid, mouse, strength, relaxation, imageSrc]);\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={`w-full h-full overflow-hidden ${className}`}\r\n    />\r\n  );\r\n};\r\n\r\nexport default GridDistortion;\r\n",
      "path": "components/pumki-ui/backgrounds/bg-grid-distort.tsx",
      "target": "components/pumki-ui/backgrounds/bg-grid-distort.tsx"
    }
  ]
}