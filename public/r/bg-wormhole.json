{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "bg-wormhole",
  "type": "registry:ui",
  "title": "Wormhole Background",
  "description": "An immersive futuristic gateway with animated grid perspective and glowing portal core.",
  "author": "Ansh Singh Sonkhia",
  "dependencies": [
    "react",
    "motion"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\r\n \r\nimport * as React from 'react';\r\nimport { motion } from 'motion/react';\r\n \r\nimport { cn } from '@/lib/utils';\r\n \r\ntype WormholeBackgroundProps = React.ComponentProps<'div'> & {\r\n  strokeColor?: string;\r\n  numberOfLines?: number;\r\n  numberOfDiscs?: number;\r\n  particleRGBColor?: [number, number, number];\r\n};\r\n \r\nfunction WormholeBackground({\r\n  strokeColor = '#737373',\r\n  numberOfLines = 50,\r\n  numberOfDiscs = 50,\r\n  particleRGBColor = [255, 255, 255],\r\n  className,\r\n  children,\r\n  ...props\r\n}: WormholeBackgroundProps) {\r\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\r\n  const animationFrameIdRef = React.useRef<number>(0);\r\n  const stateRef = React.useRef<any>({\r\n    discs: [] as any[],\r\n    lines: [] as any[],\r\n    particles: [] as any[],\r\n    clip: {},\r\n    startDisc: {},\r\n    endDisc: {},\r\n    rect: { width: 0, height: 0 },\r\n    render: { width: 0, height: 0, dpi: 1 },\r\n    particleArea: {},\r\n    linesCanvas: null,\r\n  });\r\n \r\n  const linear = (p: number) => p;\r\n  const easeInExpo = (p: number) => (p === 0 ? 0 : Math.pow(2, 10 * (p - 1)));\r\n \r\n  const tweenValue = React.useCallback(\r\n    (start: number, end: number, p: number, ease: 'inExpo' | null = null) => {\r\n      const delta = end - start;\r\n      const easeFn = ease === 'inExpo' ? easeInExpo : linear;\r\n      return start + delta * easeFn(p);\r\n    },\r\n    [],\r\n  );\r\n \r\n  const tweenDisc = React.useCallback(\r\n    (disc: any) => {\r\n      const { startDisc, endDisc } = stateRef.current;\r\n      disc.x = tweenValue(startDisc.x, endDisc.x, disc.p);\r\n      disc.y = tweenValue(startDisc.y, endDisc.y, disc.p, 'inExpo');\r\n      disc.w = tweenValue(startDisc.w, endDisc.w, disc.p);\r\n      disc.h = tweenValue(startDisc.h, endDisc.h, disc.p);\r\n    },\r\n    [tweenValue],\r\n  );\r\n \r\n  const setSize = React.useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    const rect = canvas.getBoundingClientRect();\r\n    stateRef.current.rect = { width: rect.width, height: rect.height };\r\n    stateRef.current.render = {\r\n      width: rect.width,\r\n      height: rect.height,\r\n      dpi: window.devicePixelRatio || 1,\r\n    };\r\n    canvas.width = stateRef.current.render.width * stateRef.current.render.dpi;\r\n    canvas.height =\r\n      stateRef.current.render.height * stateRef.current.render.dpi;\r\n  }, []);\r\n \r\n  const setDiscs = React.useCallback(() => {\r\n    const { width, height } = stateRef.current.rect;\r\n    stateRef.current.discs = [];\r\n    stateRef.current.startDisc = {\r\n      x: width * 0.5,\r\n      y: height * 0.45,\r\n      w: width * 0.75,\r\n      h: height * 0.7,\r\n    };\r\n    stateRef.current.endDisc = {\r\n      x: width * 0.5,\r\n      y: height * 0.95,\r\n      w: 0,\r\n      h: 0,\r\n    };\r\n    let prevBottom = height;\r\n    stateRef.current.clip = {};\r\n    for (let i = 0; i < numberOfDiscs; i++) {\r\n      const p = i / numberOfDiscs;\r\n      const disc = { p, x: 0, y: 0, w: 0, h: 0 };\r\n      tweenDisc(disc);\r\n      const bottom = disc.y + disc.h;\r\n      if (bottom <= prevBottom) {\r\n        stateRef.current.clip = { disc: { ...disc }, i };\r\n      }\r\n      prevBottom = bottom;\r\n      stateRef.current.discs.push(disc);\r\n    }\r\n    const clipPath = new Path2D();\r\n    const disc = stateRef.current.clip.disc;\r\n    clipPath.ellipse(disc.x, disc.y, disc.w, disc.h, 0, 0, Math.PI * 2);\r\n    clipPath.rect(disc.x - disc.w, 0, disc.w * 2, disc.y);\r\n    stateRef.current.clip.path = clipPath;\r\n  }, [numberOfDiscs, tweenDisc]);\r\n \r\n  const setLines = React.useCallback(() => {\r\n    const { width, height } = stateRef.current.rect;\r\n    stateRef.current.lines = [];\r\n    const linesAngle = (Math.PI * 2) / numberOfLines;\r\n    for (let i = 0; i < numberOfLines; i++) {\r\n      stateRef.current.lines.push([]);\r\n    }\r\n    stateRef.current.discs.forEach((disc: any) => {\r\n      for (let i = 0; i < numberOfLines; i++) {\r\n        const angle = i * linesAngle;\r\n        const p = {\r\n          x: disc.x + Math.cos(angle) * disc.w,\r\n          y: disc.y + Math.sin(angle) * disc.h,\r\n        };\r\n        stateRef.current.lines[i].push(p);\r\n      }\r\n    });\r\n    const offCanvas = document.createElement('canvas');\r\n    offCanvas.width = width;\r\n    offCanvas.height = height;\r\n    const ctx = offCanvas.getContext('2d');\r\n    if (!ctx) return;\r\n    stateRef.current.lines.forEach((line: any) => {\r\n      ctx.save();\r\n      let lineIsIn = false;\r\n      line.forEach((p1: any, j: number) => {\r\n        if (j === 0) return;\r\n        const p0 = line[j - 1];\r\n        if (\r\n          !lineIsIn &&\r\n          (ctx.isPointInPath(stateRef.current.clip.path, p1.x, p1.y) ||\r\n            ctx.isPointInStroke(stateRef.current.clip.path, p1.x, p1.y))\r\n        ) {\r\n          lineIsIn = true;\r\n        } else if (lineIsIn) {\r\n          ctx.clip(stateRef.current.clip.path);\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(p0.x, p0.y);\r\n        ctx.lineTo(p1.x, p1.y);\r\n        ctx.strokeStyle = strokeColor;\r\n        ctx.lineWidth = 2;\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n      });\r\n      ctx.restore();\r\n    });\r\n    stateRef.current.linesCanvas = offCanvas;\r\n  }, [numberOfLines, strokeColor]);\r\n \r\n  const initParticle = React.useCallback(\r\n    (start: boolean = false) => {\r\n      const sx =\r\n        stateRef.current.particleArea.sx +\r\n        stateRef.current.particleArea.sw * Math.random();\r\n      const ex =\r\n        stateRef.current.particleArea.ex +\r\n        stateRef.current.particleArea.ew * Math.random();\r\n      const dx = ex - sx;\r\n      const y = start\r\n        ? stateRef.current.particleArea.h * Math.random()\r\n        : stateRef.current.particleArea.h;\r\n      const r = 0.5 + Math.random() * 4;\r\n      const vy = 0.5 + Math.random();\r\n      return {\r\n        x: sx,\r\n        sx,\r\n        dx,\r\n        y,\r\n        vy,\r\n        p: 0,\r\n        r,\r\n        c: `rgba(${particleRGBColor[0]}, ${particleRGBColor[1]}, ${particleRGBColor[2]}, ${Math.random()})`,\r\n      };\r\n    },\r\n    [particleRGBColor],\r\n  );\r\n \r\n  const setParticles = React.useCallback(() => {\r\n    const { width, height } = stateRef.current.rect;\r\n    stateRef.current.particles = [];\r\n    const disc = stateRef.current.clip.disc;\r\n    stateRef.current.particleArea = {\r\n      sw: disc.w * 0.5,\r\n      ew: disc.w * 2,\r\n      h: height * 0.85,\r\n    };\r\n    stateRef.current.particleArea.sx =\r\n      (width - stateRef.current.particleArea.sw) / 2;\r\n    stateRef.current.particleArea.ex =\r\n      (width - stateRef.current.particleArea.ew) / 2;\r\n    const totalParticles = 100;\r\n    for (let i = 0; i < totalParticles; i++) {\r\n      stateRef.current.particles.push(initParticle(true));\r\n    }\r\n  }, [initParticle]);\r\n \r\n  const drawDiscs = React.useCallback(\r\n    (ctx: CanvasRenderingContext2D) => {\r\n      ctx.strokeStyle = strokeColor;\r\n      ctx.lineWidth = 2;\r\n      const outerDisc = stateRef.current.startDisc;\r\n      ctx.beginPath();\r\n      ctx.ellipse(\r\n        outerDisc.x,\r\n        outerDisc.y,\r\n        outerDisc.w,\r\n        outerDisc.h,\r\n        0,\r\n        0,\r\n        Math.PI * 2,\r\n      );\r\n      ctx.stroke();\r\n      ctx.closePath();\r\n      stateRef.current.discs.forEach((disc: any, i: number) => {\r\n        if (i % 5 !== 0) return;\r\n        if (disc.w < stateRef.current.clip.disc.w - 5) {\r\n          ctx.save();\r\n          ctx.clip(stateRef.current.clip.path);\r\n        }\r\n        ctx.beginPath();\r\n        ctx.ellipse(disc.x, disc.y, disc.w, disc.h, 0, 0, Math.PI * 2);\r\n        ctx.stroke();\r\n        ctx.closePath();\r\n        if (disc.w < stateRef.current.clip.disc.w - 5) {\r\n          ctx.restore();\r\n        }\r\n      });\r\n    },\r\n    [strokeColor],\r\n  );\r\n \r\n  const drawLines = React.useCallback((ctx: CanvasRenderingContext2D) => {\r\n    if (stateRef.current.linesCanvas) {\r\n      ctx.drawImage(stateRef.current.linesCanvas, 0, 0);\r\n    }\r\n  }, []);\r\n \r\n  const drawParticles = React.useCallback((ctx: CanvasRenderingContext2D) => {\r\n    ctx.save();\r\n    ctx.clip(stateRef.current.clip.path);\r\n    stateRef.current.particles.forEach((particle: any) => {\r\n      ctx.fillStyle = particle.c;\r\n      ctx.beginPath();\r\n      ctx.rect(particle.x, particle.y, particle.r, particle.r);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    });\r\n    ctx.restore();\r\n  }, []);\r\n \r\n  const moveDiscs = React.useCallback(() => {\r\n    stateRef.current.discs.forEach((disc: any) => {\r\n      disc.p = (disc.p + 0.001) % 1;\r\n      tweenDisc(disc);\r\n    });\r\n  }, [tweenDisc]);\r\n \r\n  const moveParticles = React.useCallback(() => {\r\n    stateRef.current.particles.forEach((particle: any, idx: number) => {\r\n      particle.p = 1 - particle.y / stateRef.current.particleArea.h;\r\n      particle.x = particle.sx + particle.dx * particle.p;\r\n      particle.y -= particle.vy;\r\n      if (particle.y < 0) {\r\n        stateRef.current.particles[idx] = initParticle();\r\n      }\r\n    });\r\n  }, [initParticle]);\r\n \r\n  const tick = React.useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) return;\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.save();\r\n    ctx.scale(stateRef.current.render.dpi, stateRef.current.render.dpi);\r\n    moveDiscs();\r\n    moveParticles();\r\n    drawDiscs(ctx);\r\n    drawLines(ctx);\r\n    drawParticles(ctx);\r\n    ctx.restore();\r\n    animationFrameIdRef.current = requestAnimationFrame(tick);\r\n  }, [moveDiscs, moveParticles, drawDiscs, drawLines, drawParticles]);\r\n \r\n  const init = React.useCallback(() => {\r\n    setSize();\r\n    setDiscs();\r\n    setLines();\r\n    setParticles();\r\n  }, [setSize, setDiscs, setLines, setParticles]);\r\n \r\n  React.useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    init();\r\n    tick();\r\n    const handleResize = () => {\r\n      setSize();\r\n      setDiscs();\r\n      setLines();\r\n      setParticles();\r\n    };\r\n    window.addEventListener('resize', handleResize);\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n      cancelAnimationFrame(animationFrameIdRef.current);\r\n    };\r\n  }, [init, tick, setSize, setDiscs, setLines, setParticles]);\r\n \r\n  return (\r\n    <div\r\n      data-slot=\"wormhole-background\"\r\n      className={cn(\r\n        'relative size-full overflow-hidden',\r\n        'before:content-[\"\"] before:absolute before:top-1/2 before:left-1/2 before:block before:size-[140%] dark:before:[background:radial-gradient(ellipse_at_50%_55%,transparent_10%,black_50%)] before:[background:radial-gradient(ellipse_at_50%_55%,transparent_10%,white_50%)] before:[transform:translate3d(-50%,-50%,0)]',\r\n        'after:content-[\"\"] after:absolute after:z-[5] after:top-1/2 after:left-1/2 after:block after:size-full after:[background:radial-gradient(ellipse_at_50%_75%,#a900ff_20%,transparent_75%)] after:[transform:translate3d(-50%,-50%,0)] after:mix-blend-overlay',\r\n        className,\r\n      )}\r\n      {...props}\r\n    >\r\n      {children}\r\n      <canvas\r\n        ref={canvasRef}\r\n        className=\"absolute inset-0 block size-full dark:opacity-20 opacity-10\"\r\n      />\r\n      <motion.div\r\n        className={cn(\r\n          'absolute top-[-71.5%] left-1/2 z-[3] w-[30%] h-[140%] rounded-b-full blur-3xl opacity-75 dark:mix-blend-plus-lighter mix-blend-plus-darker [transform:translate3d(-50%,0,0)] [background-position:0%_100%] [background-size:100%_200%]',\r\n          'dark:[background:linear-gradient(20deg,#00f8f1,#ffbd1e20_16.5%,#fe848f_33%,#fe848f20_49.5%,#00f8f1_66%,#00f8f160_85.5%,#ffbd1e_100%)_0_100%_/_100%_200%] [background:linear-gradient(20deg,#00f8f1,#ffbd1e40_16.5%,#fe848f_33%,#fe848f40_49.5%,#00f8f1_66%,#00f8f180_85.5%,#ffbd1e_100%)_0_100%_/_100%_200%]',\r\n        )}\r\n        animate={{ backgroundPosition: '0% 300%' }}\r\n        transition={{ duration: 5, ease: 'linear', repeat: Infinity }}\r\n      />\r\n      <div className=\"absolute top-0 left-0 z-[7] size-full dark:[background:repeating-linear-gradient(transparent,transparent_1px,white_1px,white_2px)] mix-blend-overlay opacity-50\" />\r\n    </div>\r\n  );\r\n}\r\n \r\nexport { WormholeBackground, type WormholeBackgroundProps };",
      "path": "components/pumki-ui/backgrounds/bg-wormhole.tsx",
      "target": "components/pumki-ui/backgrounds/bg-wormhole.tsx"
    }
  ]
}